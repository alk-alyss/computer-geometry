\documentclass{article}

\usepackage[greek]{babel}

\usepackage[a4paper, margin=1.15in]{geometry}

\usepackage{graphicx}
\usepackage{amsmath}

\usepackage{fontspec}
\setmainfont{DejaVuSansMono Nerd Font}
\setsansfont{DejaVuSansMono Nerd Font}

\title{Εργαστήριο 3}
\author{Αλκίνοος Αλυσσανδράκης 1072752}
\date{}

\begin{document}

\maketitle

\section{Principal Components}
Για να βρούμε τα Principal Components του μοντέλου αρκεί απλά να υπολογίσουμε τον πίνακα
συμμεταβλητότητας που προκύπτει από όλες τις κορυφές και στη συνέχεια να βρούμε τις
ιδιοτιμές και τα ιδιοδιανύσματα αυτού του πίνακα. Οι ιδιοτιμές είναι τα Principal
Components του μοντέλου και η ιδιοτιμή που αντιστοιχεί σε καθένα από αυτά δίχνει πόσο
πολύ επιρροή έχει στο μοντέλο.

Έχοντας βρεί τα Principal Components μπορούμε να τα αναπαραστήσουμε στη σκηνή με βέλη.
Αρχικά δημιουργούμε τρια βέλη, με τη συνάρτηση create\_arrow της βιβλιοθήκης Open3D, τα
οποία θα έχουν μήκος arrow\_length ανάλογο της ιδιοτιμής που αναπαριστούν και
τοποθετούνται με τη μια άκρη στην αρχή του συστήματος συντεταγμένων και την άλλη
άκρη να δείχνει στο σημείο (0, 0, arrow\_length).
Πρέπει τώρα να περιστρέψουμε τα βέλη γύρω από την αρχή των αξόνων προκειμένου να
συμπίπτουν με τα διανύσματα των Principal Components.

Η περιστροφή αυτή θα γίνει με την εξής διαδικασία. Γνωρίζουμε την αρχική θέση του κάθε
βέλους και την θέση στην οποία θέλουμε να καταλήξει. Θεωρούμε αυτά τα δύο σημεία ως τα
διανύσματα startVector και endVector αντίστοιχα και υπολογίζουμε το εξωτερικό γινόμενό
τους, δηλαδή ένα διάνυσμα κάθετο στα δύο προηγούμενα το normalVector.
Αύτο το διάνυσμα αποτελεί τον άξονα γύρω από τον οποίο θα γίνει η περιστροφή του βέλους.
Στη συνέχεια πρέπει να βρούμε τη γωνία ανάμεσα στο startVector και το endVector
με τον τύπο

\[
	angle = arccos\left({startVector*endVector \over ||startVector||*||endVector||}\right)
\]

Εν τέλει έχουμε τον άξονα περιστροφής και την γωνία, άρα μπορούμε να εκτελέσουμε την
περιστροφή με τις κατάλληλες διαδικασίες της Open3D, οπότε και τα βέλη καταλήγουν στη
σωστή θέση.


\section{Mesh-plane Intersection}

\subsection{Πρώτος αλγόριθμος}
Για να βρούμε ποια τρίγωνα του μοντέλου τέμνονται με ένα επιπεδό εκτελούμε την εξής
διαδικασία:

\begin{itemize}
	\item Απλώνουμε τον πίνακα των τριγώνων από $3*numberOfTriangles$ σε μονοδιάστατο πίνακα
	\item Αντικαθιστούμε τα στον πίνακα αυτό τα κορυφή που αντιστοιχούν σε κάθε τρίγωνο
		από τον πίνακα των κορυφών
	\item Για κάθε κορυφή σε αυτόν τον πίνκα υπολογίζουμε την απόσταση του από το επίπεδο
	\item Αναθέτουμε σε κάθε κορυφή την τιμή True ή False ανάλογα αν βρίσκεται πάνω ή κάτω από το επίπεδο αντίστοιχα
	\item Μετατρέπουμε ξανά τον μονοδιάστατο πίνακα σε σχήμα $3*numberOfTriangles$
	\item Κάθε τρίγωνο που έχει True σε όλες τις κορυφές βρίσκεται πάνω από το επίπεδο
	\item Κάθε τρίγωνο που έχει False σε όλες τις κορυφές βρίσκεται κατώ από το επίπεδο
	\item Αλλιώς τα τρίγωνα που έχουν True και False στις κορυφές, τέμνονται με το επίπεδο
\end{itemize}

Η διαδικασία αυτή είναι αποτελεσματική αλλά μπορεί να γίνει πιο αποδοτική καθώς ο
υπολογισμός της απόστασης του καθε κορυφή από το επίπεδο δεν γίνεται μια φορά αλλά για
κάθε τρίγωνο στο οποίο ανήκει.

\subsection{Δεύτερος αλγόριθμος}
Αν πρώτα υπολογίσουμε την απόσταση των κορυφών από το επίπεδο και αναθέσουμε σε αυτά
τιμές True ή False ανάλογα άμα είναι πάνω ή κάτω από το επίπεδο γλιτώνουμε αρκετό χρόνο
στον υπολογισμό του αποτελέσματος. Έτσι όταν έρθει η ώρα να δούμε που βρίσκεται ένα
τρίγωνο σε σχέση με το επίπεδο δεν χρειάζεται να ξαναγίνουν οι υπολογισμοί από την αρχή.
Αντ' αυτού για κάθε κορυφή του τριγώνου ανατρέχουμε στον πίνακα με τα προϋπολογισμένα
αποτελέσματα για κάθε κορυφή και όπως στην προηγούμενη περίπτωση συμπεραίνουμε αν το
τρίγωνο βρίσκεται πάνω ή κάτω από το επίπεδο ή αν τέμνεται με αυτό.

\subsection{Τρίτος αλγόριθμος}
\subsection{Τέταρτος αλγόριθμος}

\subsection{Σύγκριση χρόνων εκτέλεσης}
Οι μέσοι χρόνοι εκτέλεσης για τους τέσσερεις διαφορετικούς αλγόριθμους είναι ως εξής:

\begin{enumerate}
	\item 3.568 ms
	\item 0.655 ms
	\item 53.409 ms
	\item 20.772 ms
\end{enumerate}

Πολύ εύκολα μπορούμε να συμπεράνουμε ότι η χρήση επαναλήψεων στο κώδικα καθιστά τη
διαδικασία αρκετά πιο αργή από το να αφήσουμε τη numpy να κάνει κατευθείαν τους
υπολογισμούς πάνω στους πίνακες (το οποίο γίνεται με πολύ πιο αποδοτικό τρόπο).
Πέρα από αυτό και στις δύο περιπτώσεις (με και χωρίς επαναλήψεις) είναι εμφανές το
γεγονός ότι η προεπεξεργασία των κορυφών είναι προτιμότερη επιλογή από το να κάνουμε τους
ίδιους υπολογισμούς για κάθε τρίγωνο στο οποίο εμφανίζεται μια κορυφή.


\section{Divide Mesh}
Η διαδικασία του Mesh-plane Intersection μας επιστρέφει τρια σύνολα τριγώνων για το
μοντέλο, αυτά που τέμνονται με το επίπεδο, αυτά που βρίσκονται πάνω από το επίπεδο και
αυτά που βρίσκονται κάτω από το επίπεδο. Έχοντας αυτή την πληροφορία είναι αρκετά εύκολο
να δημιουργήσουμε τρια καινούρια mesh, ένα για κάθε σύνολο τριγώνων, να αναθέσουμε σε
αυτά ξεχωριστά χρώματα και να μετακινήσουμε τα mesh πάνω και κάτω από την τομή.
Αν στη συνέχεια διαγράψουμε το αρχικό mesh και εμφανίσουμε τα τρια καινούρια meshes, στην
οθόνη θα εμφανιστεί το διαχωρισμένο μοντέλο με κενό ανάμεσα στα τρία τμήματα του. Μάλιστα
επειδή αυτή η διαδικασία επαναλαμβάνεται όταν μετακινούμε το επίπεδο, η αλλαγή φαίνεται
σε πραγματικό χρόνο.


\end{document}
